(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./js/Main.js":[function(require,module,exports){
window.player;
window.level;
window.enemies = [];
window.currentState;

window.TILE_SIZE = 32;

window.game = new Phaser.Game(800, 480, Phaser.AUTO, '');

startLevelOne();

function startLevelOne() {
    // currentState = new LevelOneState();
    currentState = require('./game/states/LevelTwoState');

    // game.state gets the StateManager object for the game (naming is a bit misleading)
    game.state.add('LevelOne', currentState); // Adds the state to the game and assigns it a key.
    game.state.start('LevelOne');
}

function displayFps() {
    console.log('Fps: ' + game.time.fps);
}

function restartGame() {
    // TODO
}

function restartCurrentLevel() {
    currentState.restart();
}

//Reset camera to initial position
function resetCamera(xPos, yPos) {
    game.camera.x = xPos;
    game.camera.y = yPos;
}
},{"./game/states/LevelTwoState":"C:\\wamp\\www\\AndrewWorld\\js\\game\\states\\LevelTwoState.js"}],"C:\\wamp\\www\\AndrewWorld\\js\\game\\Common.js":[function(require,module,exports){
Phaser.Physics.Arcade.Body.prototype.checkWorldBounds = function () {
            if (this.position.x < this.game.physics.arcade.bounds.x && this.game.physics.arcade.checkCollision.left)
            {
                this.position.x = this.game.physics.arcade.bounds.x;
                this.velocity.x *= -this.bounce.x;
                this.blocked.left = true;
            }
            else if (this.right > this.game.physics.arcade.bounds.right && this.game.physics.arcade.checkCollision.right)
            {
                this.position.x = this.game.physics.arcade.bounds.right - this.width;
                this.velocity.x *= -this.bounce.x;
                this.blocked.right = true;
            }

            if (this.position.y < this.game.physics.arcade.bounds.y && this.game.physics.arcade.checkCollision.up)
            {
                this.position.y = this.game.physics.arcade.bounds.y;
                this.velocity.y *= -this.bounce.y;
                this.blocked.up = true;
            }
        };

Phaser.Sprite.prototype.isTouchingGround = function() {
    return this.body.onFloor() || this.body.wasTouching.down === true;
};

Phaser.Sprite.prototype.checkForCliff = function(side, platforms) {
    var offsetX;

    // Sprite position is top-left corner of sprite, so check to the left (negative offset) if looking for left cliff and check right cliff by
    // adding body width to sprite position to get an x point to the right of the sprite.
    if(side == 'left') {
        offsetX = -8; 
    } else if(side == 'right') {
        offsetX = this.body.width + 7;
    }

    var nextToPlatform;

    //First, check if the sprite is about to walk onto a platform.
    platforms.forEach(function(platform) {
        // hitTest tests if a point lies within a body.
        if(platform.body.hitTest(this.body.position.x + offsetX, this.body.position.y + this.body.height)) {
            nextToPlatform = true;
        }
    }, this);

    if(nextToPlatform) {
        return false;
    }

    //If the sprite isn't about to step onto a platform, check if it's about to step onto an empty space tile. If so, then it is at a cliff.
    var tile = level.map.getTileWorldXY(this.body.position.x + offsetX, this.body.position.y + this.body.height);
    if(this.isTouchingGround() && tile && EMPTY_SPACE_TILES.indexOf(tile.index) > -1)     {
        return true;
    }
};

Phaser.Tilemap.prototype.getTilesWithIndex = function(layer, indices) {
    var result = [];
    var layer = this.layers[layer];

    if(indices.length == 1) {
        indices = [indices]; //not sure if this works, lawl.
    }

    for(var row = 0; row < this.height; row++) {
        for(var col = 0; col < this.width; col++) {
            var tile = layer.data[row][col];
            if(indices.indexOf(tile.index) > -1) {
                result.push(tile);
            }
        }
    }

    return result;
};
},{}],"C:\\wamp\\www\\AndrewWorld\\js\\game\\Player.js":[function(require,module,exports){
Player = function(game, xSpawnPos, ySpawnPos) {
    this.game = game;
    this.sprite = null;
    this.cursors = null;
    this.jumpButton = null;
    this.jumpSound = null;
    this.climbing = false;
    this.xSpawnPos = xSpawnPos;
    this.ySpawnPos = ySpawnPos;
    this.yGravity = 400;
};
 
Player.prototype = {
 
    preload: function () {
        //  The dimensions are the dimensions of each frame in the spritesheet.
        this.game.load.spritesheet('dude', 'assets/sprites/dude.png', 32, 48);
        this.game.load.audio('jump', 'assets/sounds/jump.wav'); 
    },
 
    create: function () {
        this.sprite = this.game.add.sprite(this.xSpawnPos, this.ySpawnPos, 'dude');

        //Uncomment the line below to test the platforms.
        //this.sprite = this.game.add.sprite(90 * TILE_SIZE, 4 * TILE_SIZE, 'dude');

        this.initializePlayerPhysics();
        this.initializePlayerAnimations();
        this.initializePlayerControls();
        this.initializePlayerAudio();
        
        this.game.camera.follow(player.sprite);
    },

    initializePlayerPhysics: function() {
        this.game.physics.arcade.enable(this.sprite);
        this.sprite.body.gravity.y = this.yGravity;
        this.sprite.body.collideWorldBounds = true;
        this.sprite.body.checkCollision.down = true;

        //  Linear damping = resistance/friction on the body as it moves through the world.
        this.sprite.body.linearDamping = 1;
    },

    initializePlayerAnimations: function() {
        this.sprite.animations.add('left', [0, 1, 2, 3], 10, true);
        this.sprite.animations.add('right', [5, 6, 7, 8], 10, true);
    },

    initializePlayerControls: function() {
        this.cursors = this.game.input.keyboard.createCursorKeys();
        this.jumpButton = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);        
    },

    initializePlayerAudio: function() {
        this.jumpSound = this.game.add.audio('jump');
    },
 
    update: function() {
        this.updateCollisions();

        if(this.climbing) {
            this.updateMovementOnVine();
        } else {
            this.updateMovement();
        }

        this.sprite.checkWorldBounds = true;
        if(this.sprite.position.y > this.game.world.height) {
            this.killPlayer();
        }
    },

    updateCollisions: function() {
        game.physics.arcade.collide(this.sprite, level.layer);
        if(level.foreground != null && level.foreground != undefined) {
            game.physics.arcade.collide(this.sprite, level.foreground);    
        }
        // For each enemy type, add collisions to player.
        enemies.forEach(function(enemy) {
            game.physics.arcade.collide(this.sprite, enemy.enemies, this.killPlayer, null, this);
        }, this);
    },

    updateMovementOnVine: function() {
        this.sprite.body.velocity.y = 0;

        if (this.game.input.keyboard.justPressed(Phaser.Keyboard.SPACEBAR) && this.cursors.left.isDown) {
            this.jump();
            this.sprite.body.x -= level.vineThresholdX;
            this.endClimb();
        } else if (this.game.input.keyboard.justPressed(Phaser.Keyboard.SPACEBAR) && this.cursors.right.isDown) {
            this.jump();
            this.sprite.body.x += level.vineThresholdX;
            this.endClimb();
        } else if(this.cursors.up.isDown) {
            this.sprite.body.velocity.y = -150;
        } else if(this.cursors.down.isDown) {
            this.sprite.body.velocity.y = 150;
        } 

        if(this.sprite.body.y > level.lowestPointOnCurrentVine + level.vineThresholdY) {
            this.endClimb();
        }
    },

    updateMovement: function() {
        this.sprite.body.velocity.x = 0;

        if(this.cursors.left.isDown) {
            this.sprite.body.velocity.x = -250;
            this.sprite.animations.play('left');
        } else if(this.cursors.right.isDown) {
            this.sprite.body.velocity.x = 250;
            this.sprite.animations.play('right');
        } else {
            this.sprite.animations.stop();
            this.sprite.frame = 4;
        }
 
        if (this.jumpButton.isDown && this.sprite.isTouchingGround()) {
            this.jump();
        }
    },

    initiateClimbState: function() {
        // TODO: Change the animation
        this.climbing = true;

        this.sprite.body.gravity.y = 0;
        this.sprite.body.velocity.y = 0;
        this.sprite.body.velocity.x = 0;
    },

    jump: function() {
        this.sprite.body.position.y -= 5;
        this.sprite.body.velocity.y = -300;
        this.jumpSound.play();
    },

    endClimb: function() {
        this.climbing = false;
        this.sprite.body.gravity.y = this.yGravity;

    },

    killPlayer: function() {
        //this.sprite.kill();
        //restartCurrentLevel();
    }
};

module.exports = Player
},{}],"C:\\wamp\\www\\AndrewWorld\\js\\game\\enemies\\Birds.js":[function(require,module,exports){
function Birds(spawnLocations) {
	this.spawnLocations = spawnLocations;
	this.birdSpeed = 150;
};

Birds.prototype = {
	preload: function() {
		game.load.spritesheet('bird', 'assets/sprites/bluebirdsprite.png', 48, 32);
	},

	create: function() {
		this.enemies = game.add.group();
		this.enemies.enableBody = true;
		this.spawnLocations.forEach(function(location) {
			var bird = this.enemies.create(location.x * TILE_SIZE, location.y * TILE_SIZE, 'bird');
			this.createBird(bird, location.x * TILE_SIZE);
			}, this
		);
	},

	createBird: function(bird, xLocation) {
		bird.previousXPosition = xLocation;
		bird.animations.add('left', [2, 3], 10, true);
		bird.animations.add('right', [6, 7], 10, true);
		bird.frame = 1;
		bird.body.collideWorldBounds = true;
		bird.currentDirection = 'right';
	},

	update: function() {
		this.enemies.forEach(function(enemy) {
			if(enemy.previousXPosition == enemy.body.position.x) {
				this.changeDirection(enemy);
			}

			enemy.previousXPosition = enemy.body.position.x;

			if(enemy.currentDirection == 'left') {
				enemy.body.velocity.x = -1 * this.birdSpeed;
				enemy.animations.play('left');
			} else {
				enemy.body.velocity.x = this.birdSpeed;
				enemy.animations.play('right');
			}
		}, this);
	},

	changeDirection: function(enemy) {
		if(enemy.currentDirection == 'left') {
			enemy.currentDirection = 'right';
		} else {
			enemy.currentDirection = 'left';
		}
	},

	killAll : function() {
		this.enemies.forEach(function(enemy) {
			enemy.kill();
		});
	}
};

module.exports = Birds;
},{}],"C:\\wamp\\www\\AndrewWorld\\js\\game\\enemies\\GunDogs.js":[function(require,module,exports){
function GunDogs(spawnLocations) {
	this.spawnLocations = spawnLocations;

	this.fireRate = 1000;
	this.nextFire = 0;
};

GunDogs.prototype = {
	preload: function() {
		game.load.spritesheet('baddie', 'assets/sprites/baddie.png', 32, 32);
	},

	create: function() {
		this.enemies = game.add.group();
		this.enemies.enableBody = true;
		this.spawnLocations.forEach(function(location) {
			// .create creates a new Phaser.Sprite object and adds it to the top of this group.
			var baddie = this.enemies.create(location.x * TILE_SIZE, location.y * TILE_SIZE, 'baddie');
			this.createGunDog(baddie, location.x * TILE_SIZE);
			}, this
		);

		this.bullets = game.add.group();
		game.physics.enable(this.bullets, Phaser.Physics.ARCADE);	
	},

	createGunDog: function(baddie, xLocation) {
		baddie.body.gravity.y = 300;
		baddie.previousXPosition = xLocation;
		baddie.animations.add('left', [0, 1], 10, true);
		baddie.animations.add('right', [2, 3], 10, true);
		baddie.frame = 1;
		baddie.body.collideWorldBounds = true;
		baddie.currentDirection = 'left';
		baddie.anchor.set(0.5);
	},

	update: function() {
		this.enemies.forEach(function(enemy) {
			if(game.time.now > this.nextFire) {
				this.nextFire = game.time.now + this.fireRate;
				this.fire(enemy);
			}
		}, this);
	},

	fire: function(enemy) {
		var bullet = this.bullets.create(enemy.body.position.x, enemy.body.position.y + enemy.body.height / 2, 'baddie');
		
		game.physics.enable(bullet, Phaser.Physics.ARCADE); //Creates a default physics body on the object. The object cannot have velocity otherwise.
		bullet.checkWorldBounds = true;
		bullet.outOfBoundsKill = true;
		bullet.anchor.set(0.5);

		if(enemy.currentDirection == 'left') {
			bullet.body.velocity.x = -400;
		} else {
			bullet.body.velocity.x = 400;
		}
	}
};

module.exports = GunDogs;
},{}],"C:\\wamp\\www\\AndrewWorld\\js\\game\\enemies\\Phoenixes.js":[function(require,module,exports){
function Phoenixes(spawnLocations) {
	this.spawnLocations = spawnLocations;
	this.phoenixSpeed = 150;
	this.fireRate = 1000;
	this.nextFire = 0;
};

Phoenixes.prototype = {
	preload: function() {
		game.load.spritesheet('phoenix', 'assets/sprites/phoenixsprite.png', 48, 32);
		game.load.image('fireball', 'assets/sprites/fireball.png');
	},

	create: function() {
		this.enemies = game.add.group();
		this.enemies.enableBody = true;
		this.spawnLocations.forEach(function(location) {
			var phoenix = this.enemies.create(location.x * TILE_SIZE, location.y * TILE_SIZE, 'phoenix');
			this.createPhoenix(phoenix, location.x * TILE_SIZE);
			}, this
		);

		this.fireballs = game.add.group();
		game.physics.enable(this.fireballs, Phaser.Physics.ARCADE);
	},

	createPhoenix: function(phoenix, xLocation) {
		phoenix.previousXPosition = xLocation;
		phoenix.animations.add('left', [2, 3], 10, true);
		phoenix.animations.add('right', [6, 7], 10, true);
		phoenix.frame = 1;
		phoenix.body.collideWorldBounds = true;
		phoenix.currentDirection = 'left';
	},

	update: function() {
		this.enemies.forEach(function(enemy) {
			if(enemy.previousXPosition == enemy.body.position.x) {
				this.changeDirection(enemy);
			}

			enemy.previousXPosition = enemy.body.position.x;

			if(enemy.currentDirection == 'left') {
				enemy.body.velocity.x = -1 * this.phoenixSpeed;
				enemy.animations.play('left');
			} else {
				enemy.body.velocity.x = this.phoenixSpeed;
				enemy.animations.play('right');
			}

			if(game.time.now > this.nextFire) {
				this.nextFire = game.time.now + this.fireRate;
				this.fire(enemy);
			}
		}, this);
	},

	changeDirection: function(enemy) {
		if(enemy.currentDirection == 'left') {
			enemy.currentDirection = 'right';
		} else {
			enemy.currentDirection = 'left';
		}
	},

	fire: function(enemy) {
		var fireball = this.fireballs.create(enemy.body.position.x + enemy.body.width / 2, enemy.body.position.y + enemy.body.height, 'fireball');
		
		game.physics.enable(fireball, Phaser.Physics.ARCADE); //Creates a default physics body on the object. The object cannot have velocity otherwise.
		fireball.checkWorldBounds = true;
		fireball.outOfBoundsKill = true;
		fireball.anchor.set(0.5);

		fireball.body.velocity.y = 300;
	}
};

module.exports = Phoenixes;
},{}],"C:\\wamp\\www\\AndrewWorld\\js\\game\\levels\\LevelTwo.js":[function(require,module,exports){
require('../Common');

var VINE_TILE_INDICES = [36, 37, 56, 57];

LevelTwo = function(game, birds, gunDogs, phoenixes) {
	this.game = game;
	this.birds = birds;
	this.gunDogs = gunDogs;
	this.phoenixes = phoenixes;
	this.vineThresholdX = 15;
	this.vineThresholdY = 10;
	this.lowestPointOnCurrentVine = null;
};

LevelTwo.prototype = {
	preload: function() {
		this.game.load.tilemap('levelTwo', 'assets/levels/levelTwo.json', null, Phaser.Tilemap.TILED_JSON);
		this.game.load.image('levelTwoTiles', 'assets/tiles/area01_level_tiles.png');
	},

	create: function() {
		this.game.physics.arcade.setBoundsToWorld();

		this.map = this.game.add.tilemap('levelTwo');
		this.map.addTilesetImage('area01_level_tiles', 'levelTwoTiles');

		this.setTileCollisions();

		this.layer = this.map.createLayer('World');
		this.foreground = this.map.createLayer('Foreground');

		this.layer.resizeWorld();
		this.foreground.resizeWorld();
	},

	update: function() {
		game.physics.arcade.collide(this.birds.enemies, this.layer);
		game.physics.arcade.collide(this.phoenixes.enemies, this.layer);
		game.physics.arcade.collide(this.gunDogs.enemies, this.layer);
		game.physics.arcade.overlap(this.gunDogs.bullets, player.sprite, player.killPlayer, null, player);
	},

	restart: function() {

	},

	setTileCollisions: function() {
		this.map.setCollisionBetween(2, 8);
		this.map.setCollisionBetween(24, 27);
		this.map.setCollisionBetween(41, 45);
		this.map.setCollisionBetween(51, 53);
		this.map.setCollisionBetween(61, 62);
		this.map.setCollisionBetween(70, 72);
		this.map.setCollisionBetween(112, 114);
		this.map.setCollisionBetween(121, 125);

		// Spikes
		this.map.setTileIndexCallback(92, player.killPlayer, player);

		// Vines
		var vineTiles = this.map.getTilesWithIndex(this.map.getLayerIndex('Foreground'), VINE_TILE_INDICES);
		vineTiles.forEach(function(vineTile) {
			vineTile.setCollisionCallback(this.vineCheck, vineTile);
		}, this);
	},

	vineCheck: function() {
		var withinVineThreshold = Math.abs(player.sprite.body.x - this.worldX) < level.vineThresholdX && Math.abs(player.sprite.body.y - this.worldY) < level.vineThresholdY;


		if(!player.climbing && withinVineThreshold) {
			// worldX and worldY are the coordinates on the map. x and y are the TILE coordinates on the TILEMAP.
			player.sprite.body.x = this.worldX;

			var tileIsVine = true;
			var lowestVine;
			var currentTile = this;

			while(true) {
				var tileBelow = level.map.getTile(currentTile.x, currentTile.y + 1, level.map.getLayerIndex('Foreground'));
				if(tileBelow == null || VINE_TILE_INDICES.indexOf(tileBelow.index) < 0) {
					lowestVine = currentTile;
					break;
				}
				currentTile = tileBelow;
			}

			level.lowestPointOnCurrentVine = lowestVine.worldY;

			player.initiateClimbState();
		}
	}
};

module.exports = LevelTwo;
},{"../Common":"C:\\wamp\\www\\AndrewWorld\\js\\game\\Common.js"}],"C:\\wamp\\www\\AndrewWorld\\js\\game\\states\\LevelState.js":[function(require,module,exports){
var Player = require('../Player');

LevelState = function() {
};

LevelState.prototype = {
	preload: function() {
		player = new Player(game, this.spawnPosX, this.spawnPosY);

		player.preload();
		level.preload();

		enemies.forEach(function(enemy) {
			enemy.preload();
		});
	},

	create: function() {
		//Turn this on to enable advanced profiling (fps rate, etc.)
		//game.time.advancedTiming = true;

		level.create();
		player.create();

		enemies.forEach(function(enemy) {
			enemy.create();
		});
	},

	update: function() {
		player.update();
		level.update();
		
		enemies.forEach(function(enemy) {
			enemy.update();
		});
	},

	restart: function() {
		player.create();
		level.restart();
		resetCamera(this.startingCameraPosX, this.startingCameraPosY);
	}
};

module.exports = LevelState;
},{"../Player":"C:\\wamp\\www\\AndrewWorld\\js\\game\\Player.js"}],"C:\\wamp\\www\\AndrewWorld\\js\\game\\states\\LevelTwoState.js":[function(require,module,exports){
var LevelState = require('./LevelState');
var Birds = require('../enemies/Birds')
var GunDogs = require('../enemies/GunDogs')
var Phoenixes = require('../enemies/Phoenixes')
var LevelTwo = require('../levels/LevelTwo')

LevelTwoState = function() {
	// Pro tip: If the parent (LevelState) had properties set in its constructor and I wanted to inherit them, I'd call
	// LevelState.call(this). This would basically just run the function called LevelState. I could also pass in additional args
	// after 'this', if the function took arguments.

	this.birdSpawnLocations = [{x: 3, y:45}];
	this.phoenixSpawnLocations = [{x: 8, y: 41}];
	this.gunDogSpawnLocations = [{x: 15, y:45}];

	this.startingCameraPosX = 0;
	this.startingCameraPosY = 0;

	this.spawnPosX = 224;
	this.spawnPosY = 1440;

	this.birds = new Birds(this.birdSpawnLocations);
	this.gunDogs = new GunDogs(this.gunDogSpawnLocations);
	this.phoenixes = new Phoenixes(this.phoenixSpawnLocations);

	enemies.push(this.birds);
	enemies.push(this.gunDogs);
	enemies.push(this.phoenixes);

	level = new LevelTwo(game, this.birds, this.gunDogs, this.phoenixes);
};

LevelTwoState.prototype = Object.create(LevelState.prototype);

module.exports = LevelTwoState;
},{"../enemies/Birds":"C:\\wamp\\www\\AndrewWorld\\js\\game\\enemies\\Birds.js","../enemies/GunDogs":"C:\\wamp\\www\\AndrewWorld\\js\\game\\enemies\\GunDogs.js","../enemies/Phoenixes":"C:\\wamp\\www\\AndrewWorld\\js\\game\\enemies\\Phoenixes.js","../levels/LevelTwo":"C:\\wamp\\www\\AndrewWorld\\js\\game\\levels\\LevelTwo.js","./LevelState":"C:\\wamp\\www\\AndrewWorld\\js\\game\\states\\LevelState.js"}]},{},["./js/Main.js"]);
